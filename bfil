#!/usr/bin/perl -w
#
# bfil:
# Simple Bayesian spam filter.
#
# Copyright (c) 2003 Chris Lightfoot. All rights reserved.
# Email: chris@ex-parrot.com; WWW: http://www.ex-parrot.com/~chris/
#

my $rcsid = ''; $rcsid .= '$Id: bfil,v 1.2 2003/01/13 19:29:18 chris Exp $';

use strict;
no utf8;    # may change this decision later on....

use MIME::Base64;
use GDBM_File;
use IO::Handle;
use POSIX;
use File::Temp qw(tempfile);

if (@ARGV != 1 or $ARGV[0] !~ /^isspam|isreal|test|stats$/) {
    print STDERR <<EOF;
bfil - simple Bayesian spam filter

      fil (isspam|isreal) < mailspool
      fil test < mail
      fil stats

isspam and isreal update the spam term database with the terms in all of the
mail in the mailspool read from standard input. test reads an individual mail
and writes it to standard output with an added X-Spam-Probability: header
to tell you whether it's likely to be spam or not.

EOF
    exit(1);
}

sub push_terms ($$) {
    my ($terms, $text) = @_;
 
    # Decode base64 data, heuristically.
    eval {
        $text =~ s#((?:[A-Za-z0-9\+/]{4}){4,})#MIME::Base64::decode_base64($1)#ge;
    };
 
    # Using HTML comments to break up words is a common trick.
    $text =~ s/<!--.*?-->//gs;

    # Discard HTML tags?
#    $text =~ s/<[^>]+>/ /gs;
 
    # Treat . as part of a token, so IP addresses and hostnames are recorded.
    $text =~ s/\.\s+|\s+\./ /gs;

    foreach (split(/[^a-z0-9.-]+/si, $text)) {
        if (length($_) > 2 and length($_) < 16) {
            ++$terms->{lc $_};
        }
    }
}

# in test mode, need to save the body text and yield it up later.
my $fh = undef;
if ($ARGV[0] eq 'test') {
    $fh = File::Temp::tempfile() or die $!;
}

# open database
$ENV{HOME} ||= (getpwuid($<))[7];

my %data;
my $db;
my $i = 0;
#my $mode = ($ARGV[0] =~ /^is/ ? GDBM_WRCREAT : GDBM_READER);
my $mode = GDBM_WRCREAT;
do {
    $db = tie %data, 'GDBM_File', "$ENV{HOME}/.bfildb", $mode, 0640;
    ++$i;
    die "$ENV{HOME}/.bfildb is busy; is a fil process stuck?" if ($i > 10);
} while (!$db and $! == EAGAIN);

die "unable to open $ENV{HOME}/.bfildb" unless ($db);

delete $data{undef};

# Store things in the array as null-terminated strings and pairs of longs
# in network order, in case we want a C implementation later.
$db->filter_fetch_key(sub { no warnings 'uninitialized'; $_ =~ s/\0$// }); #??
$db->filter_store_key(sub { $_ .= "\0"    });
$db->filter_store_value(sub { $_ ||= [0, 0]; $_->[0] ||= 0; $_->[1] ||= 0; $_ = pack("NN", @$_) });
$db->filter_fetch_value(sub { $_ ||= "\0\0\0\0\0\0\0\0"; $_ = [unpack("NN", $_)] });

#
# Obtain statistics about the terms we look at.
#
if ($ARGV[0] eq 'stats') {
    my ($totspam, $totreal) = @{$data{__emails__}};
    printf("total emails: %d spam, %d nonspam\n", $totspam, $totreal);
    my $nterms = 0;
    my @probs = ( );
    my @ntermhist = qw( 0 0 0 0 0 0 0 0 0 0 );
    my $maxtermhist = 0;
    foreach (keys %data) {
        next if ($_ eq '__emails__');

        my $prob = ($data{$_}->[0] / $totspam) / ($data{$_}->[1] / $totreal + $data{$_}->[0] / $totspam);
        push(@probs, [$_, $prob]) if ($prob > 0.9 || $prob < 0.1);
        ++$nterms;

        ++$ntermhist[int(10 * $prob)];
        $maxtermhist = $ntermhist[int(10 * $prob)] if ($ntermhist[int(10 * $prob)] > $maxtermhist);
    }
    @probs = sort { $a->[1] <=> $b->[1] } @probs;

    printf("total terms: %d\n\n", $nterms);

    print "top terms:  nonspam           spam\n";
    print "            ----------------  ----------------\n";
    my $N = 15;
    my $i;
    $N = @probs if (@probs < $N);
    for ($i = 0; $i < $N; ++$i) {
        printf("            %16.16s  %16.16s\n", $probs[$i]->[0], $probs[-1-$i]->[0]);
    }
    
    print "\n";

    print "distribution of terms:\n\n";
    my $width = $ENV{COLUMNS};
    $width ||= 80;
    $width -= 10;
    for ($i = 0; $i < 10; ++$i) {
        printf("%4.2f %s\n", ($i + 0.5) / 10, "#" x int($width * $ntermhist[$i] / $maxtermhist));
    }
    
    undef $db;
    untie %data;
    exit(0);
}

my %terms;
my $line;

another_email:

%terms = ( );

# process headers
while (defined($line = <STDIN>)) {
    last if $line =~ /^$/;

    # in test mode, pass through
    print($line) or die $! if ($fh);
    
    chomp $line;
    
    if ($line =~ m#^(From|Subject):\s+(^\s+)#i) {
        push_terms(\%terms, $1);
    }
}

# process body
my $nlines = 0;
my $blank = 0;
while (defined($line = <STDIN>)) {
    # in test mode, save the body for later processing
    $fh->print($line) or die $! if ($fh);

    chomp $line;

    # try to avoid multipart separator lines.
    unless ($line =~ m#^--[^\s]{8,}$#) {
        push_terms(\%terms, $line);
    }
    
    last if ($line =~ /^From / and $blank);
    $blank = (length($line) == 0);
}



if ($ARGV[0] =~ /is(spam|real)/) {
    #
    # Add terms in given email to list.
    #
    my $I = ($1 eq 'spam' ? 0 : 1);
    my $a;
    foreach (keys %terms) {
        $a = $data{$_}; ++$a->[$I]; $data{$_} = $a;
    }
    $a = $data{__emails__}; ++$a->[$I]; $data{__emails__} = $a;
    print STDERR "." if (isatty(*STDOUT));
} else {
    #
    # Evaluate the probability of this email being spam.
    #
    my ($totspam, $totreal) = @{$data{__emails__}};
    
    # result = \frac{\product p_i}{\product p_i + \product (1 - p_i)}
    #        = \frac{a}{a + b}
    
    my @probs = ( );
    foreach (keys %terms) {
        push(@probs, ($data{$_}->[0] / $totspam) / ($data{$_}->[1] / $totreal + $data{$_}->[0] / $totspam))
            if ($data{$_}->[0] > 0 and $data{$_}->[1] > 0);
    }

    @probs = sort { abs($b - .5) <=> abs($a - .5) } @probs;

    my $a = 1;
    my $b = 1;
    my $N = 16;
    $N = $#probs if ($#probs < 16);
    foreach (@probs[0..$#probs]) {
        $a *= $_;
        $b *= (1. - $_);
    }

    my $result = $a / ($a + $b);
    printf("X-Spam-Probability: %s (p=%g)\n\n",
           ($result > .9) ? 'YES' : 'NO', $result);

    $fh->sync();
    seek($fh, 0, 0);
    while (defined($line = $fh->getline())) {
        print $line;
    }
    $fh->close();
}

goto another_email if (!eof(STDIN) and $ARGV[0] ne 'test');

undef $db;
untie %data;

exit(0);
